{"ast":null,"code":"import Chess from 'chess.js';\nimport ChessPiece from './chesspiece';\nimport Square from './square'; // when indexing, remember: [y][x]. \n\n/**\n * If the player color is black, make sure to invert the board.\n */\n\nclass Game {\n  constructor(thisPlayersColorIsWhite) {\n    this.thisPlayersColorIsWhite = thisPlayersColorIsWhite; // once initialized, this value should never change.\n    // console.log(\"this player's color is white: \" + this.thisPlayersColorIsWhite) \n\n    this.chessBoard = this.makeStartingBoard(); // the actual chessBoard\n\n    this.chess = new Chess();\n    this.toCoord = thisPlayersColorIsWhite ? {\n      0: 8,\n      1: 7,\n      2: 6,\n      3: 5,\n      4: 4,\n      5: 3,\n      6: 2,\n      7: 1\n    } : {\n      0: 1,\n      1: 2,\n      2: 3,\n      3: 4,\n      4: 5,\n      5: 6,\n      6: 7,\n      7: 8\n    };\n    this.toAlphabet = thisPlayersColorIsWhite ? {\n      0: \"a\",\n      1: \"b\",\n      2: \"c\",\n      3: \"d\",\n      4: \"e\",\n      5: \"f\",\n      6: \"g\",\n      7: \"h\"\n    } : {\n      0: \"h\",\n      1: \"g\",\n      2: \"f\",\n      3: \"e\",\n      4: \"d\",\n      5: \"c\",\n      6: \"b\",\n      7: \"a\"\n    };\n    this.toCoord2 = thisPlayersColorIsWhite ? {\n      8: 0,\n      7: 1,\n      6: 2,\n      5: 3,\n      4: 4,\n      3: 5,\n      2: 6,\n      1: 7\n    } : {\n      1: 0,\n      2: 1,\n      3: 2,\n      4: 3,\n      5: 4,\n      6: 5,\n      7: 6,\n      8: 7\n    };\n    this.toAlphabet2 = thisPlayersColorIsWhite ? {\n      \"a\": 0,\n      \"b\": 1,\n      \"c\": 2,\n      \"d\": 3,\n      \"e\": 4,\n      \"f\": 5,\n      \"g\": 6,\n      \"h\": 7\n    } : {\n      \"h\": 0,\n      \"g\": 1,\n      \"f\": 2,\n      \"e\": 3,\n      \"d\": 4,\n      \"c\": 5,\n      \"b\": 6,\n      \"a\": 7\n    };\n    this.nQueens = 1;\n  }\n\n  getBoard() {\n    return this.chessBoard;\n  } // nextPlayersTurn() {\n  //     this.isWhitesTurn = !this.isWhitesTurn\n  // }\n\n\n  setBoard(newBoard) {\n    this.chessBoard = newBoard;\n  }\n\n  movePiece(pieceId, to, isMyMove) {\n    const to2D = isMyMove ? {\n      105: 0,\n      195: 1,\n      285: 2,\n      375: 3,\n      465: 4,\n      555: 5,\n      645: 6,\n      735: 7\n    } : {\n      105: 7,\n      195: 6,\n      285: 5,\n      375: 4,\n      465: 3,\n      555: 2,\n      645: 1,\n      735: 0\n    };\n    var currentBoard = this.getBoard();\n    const pieceCoordinates = this.findPiece(currentBoard, pieceId); // can't find piece coordinates (piece doesn't exist on the board)\n\n    if (!pieceCoordinates) {\n      return;\n    }\n\n    const y = pieceCoordinates[1];\n    const x = pieceCoordinates[0]; // new coordinates\n\n    const to_y = to2D[to[1]];\n    const to_x = to2D[to[0]];\n    const originalPiece = currentBoard[y][x].getPiece();\n\n    if (y === to_y && x === to_x) {\n      return \"moved in the same position.\";\n    }\n    /**\n     * In order for this method to do anything meaningful, \n     * the 'reassign const' line of code must run. Therefore, \n     * for it to run, we must check first that the given move is valid. \n     */\n\n\n    const isPromotion = this.isPawnPromotion(to, pieceId[1]);\n    const moveAttempt = !isPromotion ? this.chess.move({\n      from: this.toChessMove([x, y], to2D),\n      to: this.toChessMove(to, to2D),\n      piece: pieceId[1]\n    }) : this.chess.move({\n      from: this.toChessMove([x, y], to2D),\n      to: this.toChessMove(to, to2D),\n      piece: pieceId[1],\n      promotion: 'q'\n    });\n    console.log(moveAttempt); // console.log(isPromotion)\n\n    if (moveAttempt === null) {\n      return \"invalid move\";\n    }\n\n    if (moveAttempt.flags === 'e') {\n      const move = moveAttempt.to;\n      const x = this.toAlphabet2[move[0]];\n      let y;\n\n      if (moveAttempt.color === 'w') {\n        y = parseInt(move[1], 10) - 1;\n      } else {\n        y = parseInt(move[1], 10) + 1;\n      }\n\n      currentBoard[this.toCoord2[y]][x].setPiece(null);\n    } // Check castling\n\n\n    const castle = this.isCastle(moveAttempt);\n\n    if (castle.didCastle) {\n      /**\n       *  The main thing we are doing here is moving the right rook\n       *  to the right position. \n       * \n       * - Get original piece by calling getPiece() on the original [x, y]\n       * - Set the new [to_x, to_y] to the original piece\n       * - Set the original [x, y] to null\n       */\n      const originalRook = currentBoard[castle.y][castle.x].getPiece();\n      currentBoard[castle.to_y][castle.to_x].setPiece(originalRook);\n      currentBoard[castle.y][castle.x].setPiece(null);\n    } // ___actually changing the board model___\n\n\n    const reassign = isPromotion ? currentBoard[to_y][to_x].setPiece(new ChessPiece('queen', false, pieceId[0] === 'w' ? 'white' : 'black', pieceId[0] === 'w' ? 'wq' + this.nQueens : 'bq' + this.nQueens)) : currentBoard[to_y][to_x].setPiece(originalPiece);\n\n    if (reassign !== \"user tried to capture their own piece\") {\n      currentBoard[y][x].setPiece(null);\n    } else {\n      return reassign;\n    } // ___actually changing the board model___\n\n\n    const checkMate = this.chess.in_checkmate() ? \" has been checkmated\" : \" has not been checkmated\";\n    console.log(this.chess.turn() + checkMate);\n\n    if (checkMate === \" has been checkmated\") {\n      return this.chess.turn() + checkMate;\n    } // changes the fill color of the opponent's king that is in check\n\n\n    const check = this.chess.in_check() ? \" is in check\" : \" is not in check\";\n    console.log(this.chess.turn() + check);\n\n    if (check === \" is in check\") {\n      return this.chess.turn() + check;\n    }\n\n    console.log(currentBoard); // update board\n\n    this.setBoard(currentBoard);\n  }\n\n  isCastle(moveAttempt) {\n    /**\n     * Assume moveAttempt is legal. \n     * \n     * {moveAttempt} -> {boolean x, y to_x, to_y} \n     * \n     * returns if a player has castled, the final position of \n     * the rook (to_x, to_y), and the original position of the rook (x, y)\n     * \n     */\n    const piece = moveAttempt.piece;\n    const move = {\n      from: moveAttempt.from,\n      to: moveAttempt.to\n    };\n    const isBlackCastle = move.from === 'e1' && move.to === 'g1' || move.from === 'e1' && move.to === 'c1';\n    const isWhiteCastle = move.from === 'e8' && move.to === 'g8' || move.from === 'e8' && move.to === 'c8';\n\n    if (!(isWhiteCastle || isBlackCastle) || piece !== 'k') {\n      return {\n        didCastle: false\n      };\n    }\n\n    let originalPositionOfRook;\n    let newPositionOfRook;\n\n    if (move.from === 'e1' && move.to === 'g1') {\n      originalPositionOfRook = 'h1';\n      newPositionOfRook = 'f1';\n    } else if (move.from === 'e1' && move.to === 'c1') {\n      originalPositionOfRook = 'a1';\n      newPositionOfRook = 'd1';\n    } else if (move.from === 'e8' && move.to === 'g8') {\n      originalPositionOfRook = 'h8';\n      newPositionOfRook = 'f8';\n    } else {\n      // e8 to c8\n      originalPositionOfRook = 'a8';\n      newPositionOfRook = 'd8';\n    }\n\n    return {\n      didCastle: true,\n      x: this.toAlphabet2[originalPositionOfRook[0]],\n      y: this.toCoord2[originalPositionOfRook[1]],\n      to_x: this.toAlphabet2[newPositionOfRook[0]],\n      to_y: this.toCoord2[newPositionOfRook[1]]\n    };\n  }\n\n  isPawnPromotion(to, piece) {\n    const res = piece === 'p' && (to[1] === 105 || to[1] === 735);\n\n    if (res) {\n      this.nQueens += 1;\n    }\n\n    return res;\n  }\n\n  toChessMove(finalPosition, to2D) {\n    let move;\n\n    if (finalPosition[0] > 100) {\n      move = this.toAlphabet[to2D[finalPosition[0]]] + this.toCoord[to2D[finalPosition[1]]];\n    } else {\n      move = this.toAlphabet[finalPosition[0]] + this.toCoord[finalPosition[1]];\n    } //  console.log(\"proposed move: \" + move)\n\n\n    return move;\n  }\n\n  findPiece(board, pieceId) {\n    // ChessBoard, String -> [Int, Int]\n    //  console.log(\"piecetofind: \" + pieceId)\n    for (var i = 0; i < 8; i++) {\n      for (var j = 0; j < 8; j++) {\n        if (board[i][j].getPieceIdOnThisSquare() === pieceId) {\n          return [j, i];\n        }\n      }\n    }\n  }\n\n  makeStartingBoard() {\n    const backRank = [\"rook\", \"knight\", \"bishop\", \"queen\", \"king\", \"bishop\", \"knight\", \"rook\"];\n    var startingChessBoard = [];\n\n    for (var i = 0; i < 8; i++) {\n      startingChessBoard.push([]);\n\n      for (var j = 0; j < 8; j++) {\n        // j is horizontal\n        // i is vertical\n        const coordinatesOnCanvas = [(j + 1) * 90 + 15, (i + 1) * 90 + 15];\n        const emptySquare = new Square(j, i, null, coordinatesOnCanvas);\n        startingChessBoard[i].push(emptySquare);\n      }\n    }\n\n    const whiteBackRankId = [\"wr1\", \"wn1\", \"wb1\", \"wq1\", \"wk1\", \"wb2\", \"wn2\", \"wr2\"];\n    const blackBackRankId = [\"br1\", \"bn1\", \"bb1\", \"bq1\", \"bk1\", \"bb2\", \"bn2\", \"br2\"];\n\n    for (var j = 0; j < 8; j += 7) {\n      for (var i = 0; i < 8; i++) {\n        if (j == 0) {\n          // top\n          // console.log(backRank[i])\n          startingChessBoard[j][this.thisPlayersColorIsWhite ? i : 7 - i].setPiece(new ChessPiece(backRank[i], false, this.thisPlayersColorIsWhite ? \"black\" : \"white\", this.thisPlayersColorIsWhite ? blackBackRankId[i] : whiteBackRankId[i]));\n          startingChessBoard[j + 1][this.thisPlayersColorIsWhite ? i : 7 - i].setPiece(new ChessPiece(\"pawn\", false, this.thisPlayersColorIsWhite ? \"black\" : \"white\", this.thisPlayersColorIsWhite ? \"bp\" + i : \"wp\" + i));\n        } else {\n          // bottom\n          startingChessBoard[j - 1][this.thisPlayersColorIsWhite ? i : 7 - i].setPiece(new ChessPiece(\"pawn\", false, this.thisPlayersColorIsWhite ? \"white\" : \"black\", this.thisPlayersColorIsWhite ? \"wp\" + i : \"bp\" + i));\n          startingChessBoard[j][this.thisPlayersColorIsWhite ? i : 7 - i].setPiece(new ChessPiece(backRank[i], false, this.thisPlayersColorIsWhite ? \"white\" : \"black\", this.thisPlayersColorIsWhite ? whiteBackRankId[i] : blackBackRankId[i]));\n        }\n      }\n    }\n\n    return startingChessBoard;\n  }\n\n}\n\nexport default Game;","map":{"version":3,"sources":["/home/arihant/Documents/Chess - Online/multiplayer-chess-game/src/chess/model/chess.js"],"names":["Chess","ChessPiece","Square","Game","constructor","thisPlayersColorIsWhite","chessBoard","makeStartingBoard","chess","toCoord","toAlphabet","toCoord2","toAlphabet2","nQueens","getBoard","setBoard","newBoard","movePiece","pieceId","to","isMyMove","to2D","currentBoard","pieceCoordinates","findPiece","y","x","to_y","to_x","originalPiece","getPiece","isPromotion","isPawnPromotion","moveAttempt","move","from","toChessMove","piece","promotion","console","log","flags","color","parseInt","setPiece","castle","isCastle","didCastle","originalRook","reassign","checkMate","in_checkmate","turn","check","in_check","isBlackCastle","isWhiteCastle","originalPositionOfRook","newPositionOfRook","res","finalPosition","board","i","j","getPieceIdOnThisSquare","backRank","startingChessBoard","push","coordinatesOnCanvas","emptySquare","whiteBackRankId","blackBackRankId"],"mappings":"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","sourcesContent":["import Chess from 'chess.js'\nimport ChessPiece from './chesspiece'\nimport Square from './square'\n// when indexing, remember: [y][x]. \n/**\n * If the player color is black, make sure to invert the board.\n */\n\n\n\n\nclass Game {\n    constructor(thisPlayersColorIsWhite) {\n        this.thisPlayersColorIsWhite = thisPlayersColorIsWhite // once initialized, this value should never change.\n        // console.log(\"this player's color is white: \" + this.thisPlayersColorIsWhite) \n        this.chessBoard = this.makeStartingBoard() // the actual chessBoard\n        this.chess = new Chess()\n\n        this.toCoord = thisPlayersColorIsWhite ? {\n            0:8, 1:7, 2: 6, 3: 5, 4: 4, 5: 3, 6: 2, 7: 1\n        } : {\n            0:1, 1:2, 2: 3, 3: 4, 4: 5, 5: 6, 6: 7, 7: 8\n        }\n        \n        this.toAlphabet = thisPlayersColorIsWhite ? {\n            0:\"a\", 1:\"b\", 2: \"c\", 3: \"d\", 4: \"e\", 5: \"f\", 6: \"g\", 7: \"h\"\n        } : {\n            0:\"h\", 1:\"g\", 2: \"f\", 3: \"e\", 4: \"d\", 5: \"c\", 6: \"b\", 7: \"a\"\n        }\n\n        this.toCoord2 = thisPlayersColorIsWhite ? {\n            8:0, 7:1, 6: 2, 5: 3, 4: 4, 3: 5, 2: 6, 1: 7\n        } : {\n            1:0, 2:1, 3: 2, 4: 3, 5: 4, 6: 5, 7: 6, 8: 7\n        }\n        \n        this.toAlphabet2 = thisPlayersColorIsWhite ? {\n            \"a\":0, \"b\":1, \"c\":2, \"d\":3, \"e\":4, \"f\":5, \"g\":6, \"h\":7\n        } : {\n            \"h\":0, \"g\":1, \"f\":2, \"e\":3, \"d\":4, \"c\":5, \"b\":6, \"a\":7\n        }\n\n        this.nQueens = 1\n    }\n\n    getBoard() {\n        return this.chessBoard\n    }\n\n    // nextPlayersTurn() {\n    //     this.isWhitesTurn = !this.isWhitesTurn\n    // }\n\n    setBoard(newBoard) {\n        this.chessBoard = newBoard\n    }\n\n    movePiece(pieceId, to, isMyMove) {\n\n        const to2D = isMyMove ? {\n            105:0, 195:1, 285: 2, 375: 3, 465: 4, 555: 5, 645: 6, 735: 7\n        } : {\n            105:7, 195:6, 285: 5, 375: 4, 465: 3, 555: 2, 645: 1, 735: 0\n        }\n\n\n        var currentBoard = this.getBoard()\n        const pieceCoordinates = this.findPiece(currentBoard, pieceId)\n        \n        \n        // can't find piece coordinates (piece doesn't exist on the board)\n        if (!pieceCoordinates) {\n            return\n        }\n\n        const y = pieceCoordinates[1]\n        const x = pieceCoordinates[0]\n\n        // new coordinates\n        const to_y = to2D[to[1]]\n        const to_x = to2D[to[0]]\n\n        const originalPiece = currentBoard[y][x].getPiece()\n    \n        if (y === to_y && x === to_x) {\n            return \"moved in the same position.\"\n        }\n\n        /**\n         * In order for this method to do anything meaningful, \n         * the 'reassign const' line of code must run. Therefore, \n         * for it to run, we must check first that the given move is valid. \n         */\n\n        const isPromotion = this.isPawnPromotion(to, pieceId[1])\n        const moveAttempt = !isPromotion ? this.chess.move({\n                from: this.toChessMove([x, y], to2D),\n                to: this.toChessMove(to, to2D),\n                piece: pieceId[1]}) \n            : \n            this.chess.move({\n                from: this.toChessMove([x, y], to2D),\n                to: this.toChessMove(to, to2D),\n                piece: pieceId[1],\n                promotion: 'q'\n            })\n\n\n         console.log(moveAttempt)\n        // console.log(isPromotion)\n\n        if (moveAttempt === null) {\n            return \"invalid move\"\n        }\n\n\n        if (moveAttempt.flags === 'e') {\n            const move = moveAttempt.to \n            const x = this.toAlphabet2[move[0]]\n            let y\n            if (moveAttempt.color === 'w') {\n                y = parseInt(move[1], 10) - 1\n            } else {\n                y = parseInt(move[1], 10) + 1 \n            }\n            currentBoard[this.toCoord2[y]][x].setPiece(null)\n        }\n\n\n\n        // Check castling\n        const castle = this.isCastle(moveAttempt)\n        if (castle.didCastle) {\n            /**\n             *  The main thing we are doing here is moving the right rook\n             *  to the right position. \n             * \n             * - Get original piece by calling getPiece() on the original [x, y]\n             * - Set the new [to_x, to_y] to the original piece\n             * - Set the original [x, y] to null\n             */\n\n            const originalRook = currentBoard[castle.y][castle.x].getPiece()\n            currentBoard[castle.to_y][castle.to_x].setPiece(originalRook)\n            currentBoard[castle.y][castle.x].setPiece(null)\n        }\n\n\n        // ___actually changing the board model___\n\n        const reassign = isPromotion ? currentBoard[to_y][to_x].setPiece(\n            new ChessPiece(\n                'queen', \n                false, \n                pieceId[0] === 'w' ? 'white' : 'black', \n                pieceId[0] === 'w' ? 'wq' + this.nQueens : 'bq' + this.nQueens))\n            : currentBoard[to_y][to_x].setPiece(originalPiece)\n\n        if (reassign !== \"user tried to capture their own piece\") {\n            currentBoard[y][x].setPiece(null)\n        } else {\n            return reassign\n        }\n\n        // ___actually changing the board model___\n\n\n        const checkMate = this.chess.in_checkmate() ? \" has been checkmated\" : \" has not been checkmated\"\n        console.log(this.chess.turn() + checkMate)\n        if (checkMate === \" has been checkmated\") {\n            return this.chess.turn() + checkMate\n        }\n        // changes the fill color of the opponent's king that is in check\n        const check = this.chess.in_check() ? \" is in check\" : \" is not in check\"\n        console.log(this.chess.turn() + check)\n        if (check === \" is in check\") {\n            return this.chess.turn() + check\n        }\n\n        console.log(currentBoard)\n        // update board\n        this.setBoard(currentBoard)\n    }\n\n\n\n    isCastle(moveAttempt) {\n        /**\n         * Assume moveAttempt is legal. \n         * \n         * {moveAttempt} -> {boolean x, y to_x, to_y} \n         * \n         * returns if a player has castled, the final position of \n         * the rook (to_x, to_y), and the original position of the rook (x, y)\n         * \n         */\n\n\n        const piece = moveAttempt.piece\n        const move = {from: moveAttempt.from, to: moveAttempt.to}\n\n        const isBlackCastle = ((move.from === 'e1' && move.to === 'g1') || (move.from === 'e1' && move.to === 'c1')) \n        const isWhiteCastle = (move.from === 'e8' && move.to === 'g8') || (move.from === 'e8' && move.to === 'c8')\n        \n\n        if (!(isWhiteCastle || isBlackCastle) || piece !== 'k') {\n            return {\n                didCastle: false\n            }\n        }\n\n        let originalPositionOfRook\n        let newPositionOfRook\n\n        if ((move.from === 'e1' && move.to === 'g1')) {\n            originalPositionOfRook = 'h1'\n            newPositionOfRook = 'f1'\n        } else if ((move.from === 'e1' && move.to === 'c1')) {\n            originalPositionOfRook = 'a1'\n            newPositionOfRook = 'd1'\n        } else if ((move.from === 'e8' && move.to === 'g8')) {\n            originalPositionOfRook = 'h8'\n            newPositionOfRook = 'f8'\n        } else { // e8 to c8\n            originalPositionOfRook = 'a8'\n            newPositionOfRook = 'd8'\n        }   \n\n    \n        return {\n            didCastle: true, \n            x: this.toAlphabet2[originalPositionOfRook[0]], \n            y: this.toCoord2[originalPositionOfRook[1]], \n            to_x: this.toAlphabet2[newPositionOfRook[0]], \n            to_y: this.toCoord2[newPositionOfRook[1]]\n        }\n    }\n\n\n    isPawnPromotion(to, piece) {\n        const res = piece === 'p' && (to[1] === 105 || to[1] === 735)\n        if (res) {\n            this.nQueens += 1\n        }\n        return res\n    }\n\n\n    toChessMove(finalPosition, to2D) {\n      \n        let move \n\n        if (finalPosition[0] > 100) {\n            move = this.toAlphabet[to2D[finalPosition[0]]] + this.toCoord[to2D[finalPosition[1]]]\n        } else {\n            move = this.toAlphabet[finalPosition[0]] + this.toCoord[finalPosition[1]]\n        }\n       \n       //  console.log(\"proposed move: \" + move)\n        return move\n    }\n\n    findPiece(board, pieceId) {\n        // ChessBoard, String -> [Int, Int]\n      //  console.log(\"piecetofind: \" + pieceId)\n        for (var i = 0; i < 8; i++) {\n            for (var j = 0; j < 8; j++) {\n                if (board[i][j].getPieceIdOnThisSquare() === pieceId) {\n                    return [j, i]\n                }\n            }\n        }\n    }\n\n    makeStartingBoard() {\n        const backRank = [\"rook\", \"knight\", \"bishop\", \"queen\", \"king\", \"bishop\", \"knight\", \"rook\"]\n        var startingChessBoard = []\n        for (var i = 0; i < 8; i++) {\n            startingChessBoard.push([])\n            for (var j = 0; j < 8; j++) {\n                // j is horizontal\n                // i is vertical\n                const coordinatesOnCanvas = [((j + 1) * 90 + 15), ((i + 1) * 90 + 15)]\n                const emptySquare = new Square(j, i, null, coordinatesOnCanvas)\n                \n                startingChessBoard[i].push(emptySquare)\n            }\n        }\n        const whiteBackRankId = [\"wr1\", \"wn1\", \"wb1\", \"wq1\", \"wk1\", \"wb2\", \"wn2\", \"wr2\"]\n        const blackBackRankId = [\"br1\", \"bn1\", \"bb1\", \"bq1\", \"bk1\", \"bb2\", \"bn2\", \"br2\"]\n        for (var j = 0; j < 8; j += 7) {\n            for (var i = 0; i < 8; i++) {\n                if (j == 0) {\n                    // top\n                    // console.log(backRank[i])\n                    startingChessBoard[j][this.thisPlayersColorIsWhite ? i : 7 - i].setPiece(new ChessPiece(backRank[i], false, this.thisPlayersColorIsWhite ? \"black\" : \"white\", this.thisPlayersColorIsWhite ? blackBackRankId[i] : whiteBackRankId[i]))\n                    startingChessBoard[j + 1][this.thisPlayersColorIsWhite ? i : 7 - i].setPiece(new ChessPiece(\"pawn\", false, this.thisPlayersColorIsWhite ? \"black\" : \"white\", this.thisPlayersColorIsWhite ? \"bp\" + i : \"wp\" + i))\n                } else {\n                    // bottom\n                    startingChessBoard[j - 1][this.thisPlayersColorIsWhite ? i : 7 - i].setPiece(new ChessPiece(\"pawn\", false, this.thisPlayersColorIsWhite ? \"white\" : \"black\", this.thisPlayersColorIsWhite ? \"wp\" + i : \"bp\" + i))\n                    startingChessBoard[j][this.thisPlayersColorIsWhite ? i : 7 - i].setPiece(new ChessPiece(backRank[i], false, this.thisPlayersColorIsWhite ? \"white\" : \"black\", this.thisPlayersColorIsWhite ? whiteBackRankId[i] : blackBackRankId[i]))\n                }\n            }\n        }\n        return startingChessBoard\n    }\n}\n\nexport default Game"]},"metadata":{},"sourceType":"module"}